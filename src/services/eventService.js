import { db } from '../firebase';
import { 
  collection, 
  doc, 
  addDoc, 
  getDoc, 
  getDocs, 
  updateDoc, 
  deleteDoc, 
  query, 
  where, 
  orderBy,
  serverTimestamp,
  increment
} from 'firebase/firestore';

/**
 * Event Service
 * Handles all event-related operations
 */

// Generate event ID from event name and category
const generateEventId = (eventName, category) => {
  const nameSlug = eventName
    .toLowerCase()
    .replace(/\s+/g, '_')
    .replace(/[^a-z0-9_]/g, '');
  
  const categorySlug = category
    .toLowerCase()
    .replace(/\s+/g, '_')
    .replace(/[^a-z0-9_]/g, '');
  
  return `${nameSlug}_${categorySlug}_${Date.now().toString().slice(-6)}`;
};

/**
 * Create a new event (Admin only)
 */
export const createEvent = async (eventData) => {
  try {
    const eventId = generateEventId(eventData.eventName, eventData.category);
    
    const event = {
      eventId,
      category: eventData.category,
      eventName: eventData.eventName,
      regFees: Number(eventData.regFees) || 0,
      dateTime: eventData.dateTime,
      endDateTime: eventData.endDateTime || null,
      location: eventData.location || '',
      briefDescription: eventData.briefDescription || '',
      image: eventData.image || '',
      pdfLink: eventData.pdfLink || '',
      contactInfo: eventData.contactInfo || '',
      isTeamEvent: Boolean(eventData.isTeamEvent),
      minTeamMembers: Number(eventData.minTeamMembers) || 1,
      maxTeamMembers: Number(eventData.maxTeamMembers) || 1,
      teamLimit: Number(eventData.teamLimit) || 0,
      currentTeams: 0,
      createdAt: serverTimestamp(),
      createdBy: eventData.createdBy || '',
    };

    const docRef = await addDoc(collection(db, 'events'), event);
    return { success: true, id: docRef.id, eventId };
  } catch (error) {
    console.error('Error creating event:', error);
    throw new Error(`Failed to create event: ${error.message}`);
  }
};

/**
 * Get all events
 */
export const getAllEvents = async (filters = {}) => {
  try {
    let q = query(collection(db, 'events'), orderBy('dateTime', 'asc'));

    // Apply category filter
    if (filters.category) {
      q = query(
        collection(db, 'events'),
        where('category', '==', filters.category),
        orderBy('dateTime', 'asc')
      );
    }

    const querySnapshot = await getDocs(q);
    const events = [];
    
    querySnapshot.forEach((doc) => {
      events.push({
        id: doc.id,
        ...doc.data(),
        dateTime: doc.data().dateTime?.toDate?.() || doc.data().dateTime,
        endDateTime: doc.data().endDateTime?.toDate?.() || doc.data().endDateTime,
        createdAt: doc.data().createdAt?.toDate?.() || doc.data().createdAt,
      });
    });

    return events;
  } catch (error) {
    console.error('Error getting events:', error);
    throw new Error(`Failed to get events: ${error.message}`);
  }
};

/**
 * Get single event by ID
 */
export const getEventById = async (eventId) => {
  try {
    // First try to find by eventId field
    const q = query(collection(db, 'events'), where('eventId', '==', eventId));
    const querySnapshot = await getDocs(q);
    
    if (!querySnapshot.empty) {
      const doc = querySnapshot.docs[0];
      return {
        id: doc.id,
        ...doc.data(),
        dateTime: doc.data().dateTime?.toDate?.() || doc.data().dateTime,
        endDateTime: doc.data().endDateTime?.toDate?.() || doc.data().endDateTime,
        createdAt: doc.data().createdAt?.toDate?.() || doc.data().createdAt,
      };
    }

    // If not found, try by document ID
    const docRef = doc(db, 'events', eventId);
    const docSnap = await getDoc(docRef);

    if (docSnap.exists()) {
      return {
        id: docSnap.id,
        ...docSnap.data(),
        dateTime: docSnap.data().dateTime?.toDate?.() || docSnap.data().dateTime,
        endDateTime: docSnap.data().endDateTime?.toDate?.() || docSnap.data().endDateTime,
        createdAt: docSnap.data().createdAt?.toDate?.() || docSnap.data().createdAt,
      };
    }

    return null;
  } catch (error) {
    console.error('Error getting event:', error);
    throw new Error(`Failed to get event: ${error.message}`);
  }
};

/**
 * Update event (Admin only)
 */
export const updateEvent = async (docId, eventData) => {
  try {
    const eventRef = doc(db, 'events', docId);
    
    const updateData = {
      ...eventData,
      updatedAt: serverTimestamp(),
    };

    await updateDoc(eventRef, updateData);
    return { success: true };
  } catch (error) {
    console.error('Error updating event:', error);
    throw new Error(`Failed to update event: ${error.message}`);
  }
};

/**
 * Delete event (Admin only)
 */
export const deleteEvent = async (docId) => {
  try {
    await deleteDoc(doc(db, 'events', docId));
    return { success: true };
  } catch (error) {
    console.error('Error deleting event:', error);
    throw new Error(`Failed to delete event: ${error.message}`);
  }
};

/**
 * Increment team count for event
 */
export const incrementEventTeamCount = async (docId) => {
  try {
    const eventRef = doc(db, 'events', docId);
    await updateDoc(eventRef, {
      currentTeams: increment(1)
    });
    return { success: true };
  } catch (error) {
    console.error('Error incrementing team count:', error);
    throw new Error(`Failed to increment team count: ${error.message}`);
  }
};

/**
 * Decrement team count for event
 */
export const decrementEventTeamCount = async (docId) => {
  try {
    const eventRef = doc(db, 'events', docId);
    await updateDoc(eventRef, {
      currentTeams: increment(-1)
    });
    return { success: true };
  } catch (error) {
    console.error('Error decrementing team count:', error);
    throw new Error(`Failed to decrement team count: ${error.message}`);
  }
};

/**
 * Check if event has reached team limit
 */
export const isEventFull = async (docId) => {
  try {
    const event = await getEventById(docId);
    if (!event) return false;
    
    if (event.teamLimit === 0) return false; // No limit
    return event.currentTeams >= event.teamLimit;
  } catch (error) {
    console.error('Error checking event capacity:', error);
    return false;
  }
};
